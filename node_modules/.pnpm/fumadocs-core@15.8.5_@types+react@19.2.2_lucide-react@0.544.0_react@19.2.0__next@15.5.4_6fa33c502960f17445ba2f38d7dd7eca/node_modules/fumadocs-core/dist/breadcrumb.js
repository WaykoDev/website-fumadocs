import {
  findPath
} from "./chunk-2IYQ7QMS.js";
import {
  normalizeUrl
} from "./chunk-PFNP6PEB.js";
import "./chunk-U67V476Y.js";

// src/breadcrumb.tsx
import { useMemo } from "react";
function useBreadcrumb(url, tree, options) {
  return useMemo(
    () => getBreadcrumbItems(url, tree, options),
    [tree, url, options]
  );
}
function getBreadcrumbItems(url, tree, options = {}) {
  return getBreadcrumbItemsFromPath(
    tree,
    searchPath(tree.children, url) ?? [],
    options
  );
}
function getBreadcrumbItemsFromPath(tree, path, options) {
  const {
    includePage = false,
    includeSeparator = false,
    includeRoot = false
  } = options;
  let items = [];
  for (let i = 0; i < path.length; i++) {
    const item = path[i];
    switch (item.type) {
      case "page":
        if (includePage)
          items.push({
            name: item.name,
            url: item.url
          });
        break;
      case "folder":
        if (item.root && !includeRoot) {
          items = [];
          break;
        }
        if (i === path.length - 1 || item.index !== path[i + 1]) {
          items.push({
            name: item.name,
            url: item.index?.url
          });
        }
        break;
      case "separator":
        if (item.name && includeSeparator)
          items.push({
            name: item.name
          });
        break;
    }
  }
  if (includeRoot) {
    items.unshift({
      name: tree.name,
      url: typeof includeRoot === "object" ? includeRoot.url : void 0
    });
  }
  return items;
}
function searchPath(nodes, url) {
  const normalizedUrl = normalizeUrl(url);
  return findPath(
    nodes,
    (node) => node.type === "page" && node.url === normalizedUrl
  );
}
export {
  getBreadcrumbItems,
  getBreadcrumbItemsFromPath,
  searchPath,
  useBreadcrumb
};
