import { I as Item, F as Folder, S as Separator, R as Root } from './definitions-Q95-psoo.js';
import { I18nConfig } from './i18n/index.js';
import { ReactNode } from 'react';

interface FileInfo {
    /**
     * File path without extension
     *
     * @deprecated obtain it with `join(dirname, name)`
     */
    flattenedPath: string;
    /**
     * path of file (unparsed)
     */
    path: string;
    /**
     * File name without extension
     */
    name: string;
    /**
     * file extension from the last `.`, like `.md`
     *
     * empty string if no file extension
     */
    ext: string;
    dirname: string;
}
declare function basename(path: string, ext?: string): string;
declare function extname(path: string): string;
declare function dirname(path: string): string;
declare function parseFilePath(path: string): FileInfo;
/**
 * Split path into segments, trailing/leading slashes are removed
 */
declare function splitPath(path: string): string[];
/**
 * Resolve paths, slashes within the path will be ignored
 * @param paths - Paths to join
 * @example
 * ```
 * ['a','b'] // 'a/b'
 * ['/a'] // 'a'
 * ['a', '/b'] // 'a/b'
 * ['a', '../b/c'] // 'b/c'
 * ```
 */
declare function joinPath(...paths: string[]): string;
declare function slash(path: string): string;

type path_FileInfo = FileInfo;
declare const path_basename: typeof basename;
declare const path_dirname: typeof dirname;
declare const path_extname: typeof extname;
declare const path_joinPath: typeof joinPath;
declare const path_parseFilePath: typeof parseFilePath;
declare const path_slash: typeof slash;
declare const path_splitPath: typeof splitPath;
declare namespace path {
  export { type path_FileInfo as FileInfo, path_basename as basename, path_dirname as dirname, path_extname as extname, path_joinPath as joinPath, path_parseFilePath as parseFilePath, path_slash as slash, path_splitPath as splitPath };
}

interface LoaderPlugin<Page extends PageData = PageData, Meta extends MetaData = MetaData> {
    name?: string;
    /**
     * Change the order of plugin:
     * - `pre`: before normal plugins
     * - `post`: after normal plugins
     */
    enforce?: 'pre' | 'post';
    /**
     * receive & replace loader options
     */
    config?: (config: ResolvedLoaderConfig) => ResolvedLoaderConfig | void | undefined;
    /**
     * transform the storage after loading
     */
    transformStorage?: (context: {
        storage: ContentStorage<Page, Meta>;
    }) => void;
    /**
     * transform the generated page tree
     */
    transformPageTree?: PageTreeTransformer<Page, Meta>;
}
declare function buildPlugins(plugins: (LoaderPlugin | LoaderPlugin[] | undefined)[]): LoaderPlugin[];

type TransformContentStorage = (context: {
    storage: ContentStorage;
}) => void;
interface LegacyLoaderOptions {
    /**
     * We recommend you to use `plugins` instead
     */
    transformers?: TransformContentStorage[];
}
interface LegacyPageTreeOptions<Page extends PageData = PageData, Meta extends MetaData = MetaData> {
    /**
     * @deprecated use `plugins` instead
     */
    attachFile?: (node: Item, file?: PageFile<Page>) => Item;
    /**
     * @deprecated use `plugins` instead
     */
    attachFolder?: (node: Folder, folder: {
        children: (PageFile<Page> | MetaFile<Meta>)[];
    }, meta?: MetaFile<Meta>) => Folder;
    /**
     * @deprecated use `plugins` instead
     */
    attachSeparator?: (node: Separator) => Separator;
    /**
     * We recommend you to use `plugins` instead
     */
    transformers?: PageTreeTransformer<Page, Meta>[];
}

type IconResolver = (icon: string | undefined) => ReactNode;

interface LoaderConfig {
    source: SourceConfig;
    i18n: I18nConfig | undefined;
}
interface SourceConfig {
    pageData: PageData;
    metaData: MetaData;
}
interface LoaderOptions<S extends SourceConfig = SourceConfig, I18n extends I18nConfig | undefined = I18nConfig | undefined> extends LegacyLoaderOptions {
    baseUrl: string;
    i18n?: I18n;
    url?: UrlFn;
    /**
     * Additional options for page tree builder
     */
    pageTree?: PageTreeOptions & LegacyPageTreeOptions<S['pageData'], S['metaData']>;
    plugins?: (LoaderPlugin<S['pageData'], S['metaData']> | LoaderPlugin<S['pageData'], S['metaData']>[] | undefined)[];
    icon?: IconResolver;
    slugs?: (info: FileInfo) => string[];
}
interface ResolvedLoaderConfig {
    source: Source;
    url: UrlFn;
    plugins?: LoaderPlugin[];
    pageTree?: PageTreeOptions;
    i18n?: I18nConfig | undefined;
}
interface Source<Config extends SourceConfig = SourceConfig> {
    files: VirtualFile<Config>[];
}
interface SharedFileInfo {
    /**
     * Virtualized file path (parsed)
     *
     * @deprecated Use `path` instead.
     */
    file: FileInfo;
    /**
     * Virtualized file path (relative to content directory)
     *
     * @example `docs/page.mdx`
     */
    path: string;
    /**
     * Absolute path of the file (can be empty)
     */
    absolutePath: string;
}
interface Page<Data = PageData> extends SharedFileInfo {
    slugs: string[];
    url: string;
    data: Data;
    locale?: string | undefined;
}
interface Meta<Data = MetaData> extends SharedFileInfo {
    data: Data;
}
interface LoaderOutput<Config extends LoaderConfig> {
    pageTree: Config['i18n'] extends I18nConfig ? Record<string, Root> : Root;
    getPageTree: (locale?: string) => Root;
    getPageByHref: (href: string, options?: {
        language?: string;
        /**
         * resolve relative file paths in `href` from specified dirname, must be a virtual path.
         */
        dir?: string;
    }) => {
        page: Page<Config['source']['pageData']>;
        hash?: string;
    } | undefined;
    /**
     * @internal
     */
    _i18n?: I18nConfig;
    /**
     * Get a list of pages from specified language
     *
     * @param language - If empty, list pages from all languages.
     */
    getPages: (language?: string) => Page<Config['source']['pageData']>[];
    /**
     * get each language and its pages, empty if i18n is not enabled.
     */
    getLanguages: () => {
        language: string;
        pages: Page<Config['source']['pageData']>[];
    }[];
    /**
     * Get page with slugs
     *
     * @param language - If empty, the default language will be used
     */
    getPage: (slugs: string[] | undefined, language?: string) => Page<Config['source']['pageData']> | undefined;
    getNodePage: (node: Item, language?: string) => Page<Config['source']['pageData']> | undefined;
    getNodeMeta: (node: Folder, language?: string) => Meta<Config['source']['metaData']> | undefined;
    /**
     * generate static params for Next.js SSG
     *
     * @param slug - customise parameter name for slugs
     * @param lang - customise parameter name for lang
     */
    generateParams: <TSlug extends string = 'slug', TLang extends string = 'lang'>(slug?: TSlug, lang?: TLang) => (Record<TSlug, string[]> & Record<TLang, string>)[];
}
declare function createGetUrl(baseUrl: string, i18n?: I18nConfig): UrlFn;
declare function loader<Config extends SourceConfig, I18n extends I18nConfig | undefined = undefined>(source: Source<Config>, options: LoaderOptions<NoInfer<Config>, I18n>): LoaderOutput<{
    source: Config;
    i18n: I18n;
}>;
declare function loader<Config extends SourceConfig, I18n extends I18nConfig | undefined = undefined>(options: LoaderOptions<NoInfer<Config>, I18n> & {
    source: Source<Config>;
}): LoaderOutput<{
    source: Config;
    i18n: I18n;
}>;
type _ConfigUnion_<T extends Record<string, Source>> = {
    [K in keyof T]: T[K] extends Source<infer Config> ? {
        pageData: Config['pageData'] & {
            type: K;
        };
        metaData: Config['metaData'] & {
            type: K;
        };
    } : never;
}[keyof T];
declare function multiple<T extends Record<string, Source>>(sources: T): Source<_ConfigUnion_<T>>;
/**
 * map virtual files in source
 */
declare function map<Config extends SourceConfig>(source: Source<Config>): {
    page<$Page extends PageData>(fn: (entry: VirtualPage<Config["pageData"]>) => VirtualPage<$Page>): Source<{
        pageData: $Page;
        metaData: Config["metaData"];
    }>;
    meta<$Meta extends MetaData>(fn: (entry: VirtualMeta<Config["metaData"]>) => VirtualMeta<$Meta>): Source<{
        pageData: Config["pageData"];
        metaData: $Meta;
    }>;
};

interface MetaData {
    icon?: string | undefined;
    title?: string | undefined;
    root?: boolean | undefined;
    pages?: string[] | undefined;
    defaultOpen?: boolean | undefined;
    description?: string | undefined;
}
interface PageData {
    icon?: string | undefined;
    title?: string;
    description?: string | undefined;
}
interface BaseVirtualFile {
    /**
     * Virtualized path (relative to content directory)
     *
     * @example `docs/page.mdx`
     */
    path: string;
    /**
     * Absolute path of the file
     */
    absolutePath?: string;
}
interface VirtualPage<Data extends PageData> extends BaseVirtualFile {
    type: 'page';
    /**
     * Specified Slugs for page
     */
    slugs?: string[];
    data: Data;
}
interface VirtualMeta<Data extends MetaData> extends BaseVirtualFile {
    type: 'meta';
    data: Data;
}
type VirtualFile<Config extends SourceConfig = SourceConfig> = VirtualPage<Config['pageData']> | VirtualMeta<Config['metaData']>;
type InferPageType<Utils extends LoaderOutput<any>> = Utils extends LoaderOutput<infer Config> ? Page<Config['source']['pageData']> : never;
type InferMetaType<Utils extends LoaderOutput<any>> = Utils extends LoaderOutput<infer Config> ? Meta<Config['source']['metaData']> : never;
/**
 * @internal
 */
type UrlFn = (slugs: string[], locale?: string) => string;

/**
 * In memory file system.
 */
declare class FileSystem<File> {
    files: Map<string, File>;
    folders: Map<string, string[]>;
    constructor(inherit?: FileSystem<File>);
    read(path: string): File | undefined;
    /**
     * get the direct children of folder (in virtual file path)
     */
    readDir(path: string): string[] | undefined;
    write(path: string, file: File): void;
    /**
     * Delete files at specified path.
     *
     * @param path - the target path.
     * @param [recursive=false] - if set to `true`, it will also delete directories.
     */
    delete(path: string, recursive?: boolean): boolean;
    getFiles(): string[];
    makeDir(path: string): void;
}

type ContentStorage<Page extends PageData = PageData, Meta extends MetaData = MetaData> = FileSystem<MetaFile<Meta> | PageFile<Page>>;
interface MetaFile<Data extends MetaData = MetaData> {
    path: string;
    absolutePath: string;
    format: 'meta';
    data: Data;
}
interface PageFile<Data extends PageData = PageData> {
    path: string;
    absolutePath: string;
    format: 'page';
    slugs: string[];
    data: Data;
}

interface PageTreeBuilderContext<Page extends PageData = PageData, Meta extends MetaData = MetaData> {
    /**
     * @internal resolve paths without extensions
     */
    resolveName: (name: string, format: 'meta' | 'page') => string;
    options: PageTreeOptions;
    transformers: PageTreeTransformer<Page, Meta>[];
    builder: PageTreeBuilder;
    storage: ContentStorage<Page, Meta>;
    getUrl: UrlFn;
    storages?: Record<string, ContentStorage<Page, Meta>>;
    locale?: string;
    visitedPaths: Set<string>;
}
interface PageTreeTransformer<Page extends PageData = PageData, Meta extends MetaData = MetaData> {
    file?: (this: PageTreeBuilderContext<Page, Meta>, node: Item, filePath?: string) => Item;
    folder?: (this: PageTreeBuilderContext<Page, Meta>, node: Folder, folderPath: string, metaPath?: string) => Folder;
    separator?: (this: PageTreeBuilderContext<Page, Meta>, node: Separator) => Separator;
    root?: (this: PageTreeBuilderContext<Page, Meta>, node: Root) => Root;
}
interface PageTreeOptions {
    id?: string;
    /**
     * Remove references to the file path of original nodes (`$ref`)
     *
     * @defaultValue false
     */
    noRef?: boolean;
    /**
     * generate fallback page tree
     *
     * @defaultValue true
     */
    generateFallback?: boolean;
}
interface PageTreeBuilder {
    build: (storage: ContentStorage, options?: PageTreeOptions) => Root;
    buildI18n: (storages: Record<string, ContentStorage>, options?: PageTreeOptions) => Record<string, Root>;
}
declare function createPageTreeBuilder(getUrl: UrlFn, plugins?: LoaderPlugin[]): PageTreeBuilder;

export { type ContentStorage as C, type FileInfo as F, type InferPageType as I, type LoaderOutput as L, type MetaFile as M, type PageTreeTransformer as P, type ResolvedLoaderConfig as R, type SourceConfig as S, type TransformContentStorage as T, type UrlFn as U, type VirtualPage as V, type _ConfigUnion_ as _, type LoaderConfig as a, type PageTreeBuilder as b, createPageTreeBuilder as c, type PageTreeBuilderContext as d, type PageTreeOptions as e, FileSystem as f, type PageFile as g, parseFilePath as h, type LoaderOptions as i, type Source as j, type Page as k, type Meta as l, createGetUrl as m, loader as n, multiple as o, path as p, map as q, type MetaData as r, type PageData as s, type VirtualMeta as t, type VirtualFile as u, type InferMetaType as v, type LoaderPlugin as w, buildPlugins as x };
