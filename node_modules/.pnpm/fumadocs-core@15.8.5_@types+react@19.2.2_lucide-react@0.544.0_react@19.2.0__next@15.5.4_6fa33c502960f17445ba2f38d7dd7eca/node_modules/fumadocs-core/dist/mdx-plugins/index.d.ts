export { Options as RemarkGfmOptions, default as remarkGfm } from 'remark-gfm';
import { Root } from 'hast';
import { RehypeShikiOptions } from '@shikijs/rehype';
import { Processor, Transformer } from 'unified';
import { ShikiTransformer } from 'shiki';
import { Root as Root$1, BlockContent, Text } from 'mdast';
export { a as StructureOptions, S as StructuredData, r as remarkStructure, s as structure } from '../remark-structure-DkCXCzpD.js';
export { a as RemarkCodeTabOptions, R as RemarkHeadingOptions, b as remarkCodeTab, r as remarkHeading } from '../remark-code-tab-DmyIyi6m.js';
import { MdxJsxAttribute, MdxJsxFlowElement } from 'mdast-util-mdx-jsx';

type CodeBlockIcon = {
    viewBox: string;
    fill: string;
    d: string;
} | string;
interface IconOptions {
    shortcuts?: Record<string, string>;
    extend?: Record<string, CodeBlockIcon>;
}
/**
 * Inject icons to `icon` property (as HTML)
 */
declare function transformerIcon(options?: IconOptions): ShikiTransformer;

declare const rehypeCodeDefaultOptions: RehypeCodeOptions;
type RehypeCodeOptions = RehypeShikiOptions & {
    /**
     * Filter meta string before processing
     */
    filterMetaString?: (metaString: string) => string;
    /**
     * Add icon to code blocks
     */
    icon?: IconOptions | false;
    /**
     * Wrap code blocks in `<Tab>` component when "tab" meta string presents
     *
     * @defaultValue true
     */
    tab?: boolean;
    /**
     * Enable Shiki's experimental JS engine
     *
     * @defaultValue false
     */
    experimentalJSEngine?: boolean;
};
/**
 * Handle codeblocks
 */
declare function rehypeCode(this: Processor, _options?: Partial<RehypeCodeOptions>): Transformer<Root, Root>;
declare function transformerTab(): ShikiTransformer;

interface RemarkImageOptions {
    /**
     * Directory or base URL to resolve absolute image paths
     */
    publicDir?: string;
    /**
     * Preferred placeholder type, only available with `useImport` + local images.
     *
     * @defaultValue 'blur'
     */
    placeholder?: 'blur' | 'none';
    /**
     * Define how to handle errors when fetching image size.
     *
     * - `error` (default): throw an error.
     * - `ignore`: do absolutely nothing (Next.js Image component may complain).
     * - `hide`: remove that image element.
     *
     * @defaultValue 'error'
     */
    onError?: 'error' | 'hide' | 'ignore' | ((error: Error) => void);
    /**
     * Import images in the file, and let bundlers handle it.
     *
     * ```tsx
     * import MyImage from "./public/img.png";
     *
     * <img src={MyImage} />
     * ```
     *
     * When disabled, `placeholder` will be ignored.
     *
     * @defaultValue true
     */
    useImport?: boolean;
    /**
     * Fetch image size of external URLs
     *
     * @defaultValue true
     */
    external?: boolean;
}
/**
 * Turn images into Next.js Image compatible usage.
 */
declare function remarkImage({ placeholder, external, useImport, onError, publicDir, }?: RemarkImageOptions): Transformer<Root$1, Root$1>;

interface RemarkAdmonitionOptions {
    tag?: string;
    /**
     * Map type to another type
     */
    typeMap?: Record<string, string>;
}
/**
 * Remark Plugin to support Admonition syntax
 *
 * Useful when Migrating from Docusaurus
 */
declare function remarkAdmonition(options?: RemarkAdmonitionOptions): Transformer<Root$1, Root$1>;

interface RehypeTocOptions {
    /**
     * Export generated toc as a variable
     *
     * @defaultValue true
     */
    exportToc?: boolean;
}
declare function rehypeToc(this: Processor, { exportToc }?: RehypeTocOptions): Transformer<Root, Root>;

interface RemarkStepsOptions {
    /**
     * Class name for steps container
     *
     * @defaultValue fd-steps
     */
    steps?: string;
    /**
     * Class name for step container
     *
     * @defaultValue fd-step
     */
    step?: string;
}
/**
 * Convert headings in the format of `1. Hello World` into steps.
 */
declare function remarkSteps({ steps, step, }?: RemarkStepsOptions): Transformer<Root$1, Root$1>;

interface PackageManager {
    name: string;
    /**
     * Default to `name`
     */
    value?: string;
    /**
     * Convert from npm to another package manager
     */
    command: (command: string) => string | undefined;
}
interface RemarkNpmOptions {
    /**
     * Persist Tab value (Fumadocs UI only)
     *
     * @defaultValue false
     */
    persist?: {
        id: string;
    } | false;
    packageManagers?: PackageManager[];
}
/**
 * It generates multiple tabs of codeblocks for different package managers from a npm command codeblock.
 */
declare function remarkNpm({ persist, packageManagers, }?: RemarkNpmOptions): Transformer<Root$1, Root$1>;

interface CodeBlockTabsOptions {
    attributes?: MdxJsxAttribute[];
    defaultValue?: string;
    persist?: {
        id: string;
    } | false;
    triggers: {
        value: string;
        children: (BlockContent | Text)[];
    }[];
    tabs: {
        value: string;
        children: BlockContent[];
    }[];
}
declare function generateCodeBlockTabs({ persist, defaultValue, triggers, tabs, ...options }: CodeBlockTabsOptions): MdxJsxFlowElement;
interface CodeBlockAttributes<Name extends string = string> {
    attributes: Partial<Record<Name, string | null>>;
    rest: string;
}
/**
 * Parse Fumadocs-style code block attributes from meta string, like `title="hello world"`
 */
declare function parseCodeBlockAttributes<Name extends string = string>(meta: string, allowedNames?: Name[]): CodeBlockAttributes<Name>;

interface FileNode {
    depth: number;
    type: 'file';
    name: string;
}
interface FolderNode {
    depth: number;
    type: 'folder';
    name: string;
    children: Node[];
}
type Node = FileNode | FolderNode;
interface RemarkMdxFilesOptions {
    /**
     * @defaultValue files
     */
    lang?: string;
    toMdx?: (node: Node) => MdxJsxFlowElement;
}
/**
 * Convert codeblocks with `files` as lang, like:
 *
 * ```files
 * project
 * ├── src
 * │   ├── index.js
 * │   └── utils
 * │       └── helper.js
 * ├── package.json
 * ```
 *
 * into MDX `<Files />` component
 */
declare function remarkMdxFiles(options?: RemarkMdxFilesOptions): Transformer<Root$1, Root$1>;

interface RemarkMdxMermaidOptions {
    /**
     * @defaultValue mermaid
     */
    lang?: string;
}
/**
 * Convert `mermaid` codeblocks into `<Mermaid />` MDX component
 */
declare function remarkMdxMermaid(options?: RemarkMdxMermaidOptions): Transformer<Root$1, Root$1>;

export { type CodeBlockAttributes, type CodeBlockIcon, type CodeBlockTabsOptions, type RehypeCodeOptions, type RehypeTocOptions, type RemarkAdmonitionOptions, type RemarkImageOptions, type RemarkMdxFilesOptions, type RemarkMdxMermaidOptions, type RemarkNpmOptions, type RemarkStepsOptions, generateCodeBlockTabs, parseCodeBlockAttributes, rehypeCode, rehypeCodeDefaultOptions, rehypeToc, remarkAdmonition, remarkImage, remarkMdxFiles, remarkMdxMermaid, remarkNpm, remarkSteps, transformerIcon, transformerTab };
