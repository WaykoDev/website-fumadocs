import {
  getGlobPatterns,
  ident,
  toImportPath
} from "./chunk-6Y5JDZHD.js";
import {
  loadConfig
} from "./chunk-LGYVNESJ.js";
import {
  findConfigFile
} from "./chunk-XMFLD5J6.js";

// src/vite/postinstall.ts
import fs from "fs/promises";
import path from "path";

// src/vite/generate-glob.ts
function generateGlob(name, patterns, globOptions) {
  const options = {
    ...globOptions,
    query: {
      ...globOptions?.query,
      collection: name
    }
  };
  return `import.meta.glob(${JSON.stringify(mapGlobPatterns(patterns))}, ${JSON.stringify(options, null, 2)})`;
}
function mapGlobPatterns(patterns) {
  return patterns.map(enforceRelative);
}
function enforceRelative(file) {
  if (file.startsWith("./")) return file;
  if (file.startsWith("/")) return `.${file}`;
  return `./${file}`;
}
function getGlobBase(collection) {
  let dir = collection.dir;
  if (Array.isArray(dir)) {
    if (dir.length !== 1)
      throw new Error(
        `[Fumadocs MDX] Vite Plugin doesn't support multiple \`dir\` for a collection at the moment.`
      );
    dir = dir[0];
  }
  return enforceRelative(dir);
}

// src/vite/generate.ts
function docs(name, collection) {
  const obj = [
    ident(`doc: ${doc(name, collection.docs)}`),
    ident(`meta: ${meta(name, collection.meta)}`)
  ].join(",\n");
  return `{
${obj}
}`;
}
function doc(name, collection) {
  const patterns = getGlobPatterns(collection);
  const base = getGlobBase(collection);
  const docGlob = generateGlob(name, patterns, {
    base
  });
  if (collection.async) {
    const headBlob = generateGlob(name, patterns, {
      query: {
        only: "frontmatter"
      },
      import: "frontmatter",
      base
    });
    return `create.docLazy("${name}", "${base}", ${headBlob}, ${docGlob})`;
  }
  return `create.doc("${name}", "${base}", ${docGlob})`;
}
function meta(name, collection) {
  const patterns = getGlobPatterns(collection);
  const base = getGlobBase(collection);
  return `create.meta("${name}", "${base}", ${generateGlob(name, patterns, {
    import: "default",
    base
  })})`;
}
function entry(configPath, config, outDir, jsExtension) {
  const lines = [
    '/// <reference types="vite/client" />',
    `import { fromConfig } from 'fumadocs-mdx/runtime/vite';`,
    `import type * as Config from '${toImportPath(configPath, {
      relativeTo: outDir,
      jsExtension
    })}';`,
    "",
    `export const create = fromConfig<typeof Config>();`
  ];
  for (const [name, collection] of config.collections.entries()) {
    let body;
    if (collection.type === "docs") {
      body = docs(name, collection);
    } else if (collection.type === "meta") {
      body = meta(name, collection);
    } else {
      body = doc(name, collection);
    }
    lines.push("");
    lines.push(`export const ${name} = ${body};`);
  }
  return lines.join("\n");
}

// src/vite/postinstall.ts
async function postInstall(configPath = findConfigFile(), outDir, addJsExtension = false) {
  const config = await loadConfig(configPath, "node_modules", void 0, true);
  const outFile = "source.generated.ts";
  if (outDir) {
    await fs.mkdir(outDir, { recursive: true });
  }
  await fs.writeFile(
    outDir ? path.join(outDir, outFile) : outFile,
    entry(configPath, config, outDir ?? process.cwd(), addJsExtension)
  );
  console.log("[MDX] types generated");
}

export {
  entry,
  postInstall
};
