"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/loaders/mdx/preset.ts
var preset_exports = {};
__export(preset_exports, {
  getDefaultMDXOptions: () => getDefaultMDXOptions
});
function pluginOption(def, options = []) {
  const list = def(Array.isArray(options) ? options : []).filter(
    Boolean
  );
  if (typeof options === "function") {
    return options(list);
  }
  return list;
}
function getDefaultMDXOptions({
  valueToExport = [],
  rehypeCodeOptions,
  remarkImageOptions,
  remarkHeadingOptions,
  remarkStructureOptions,
  remarkCodeTabOptions,
  remarkNpmOptions,
  _withoutBundler = false,
  ...mdxOptions
}) {
  const remarkPlugins = pluginOption(
    (v) => [
      plugins.remarkGfm,
      [
        plugins.remarkHeading,
        {
          generateToc: false,
          ...remarkHeadingOptions
        }
      ],
      remarkImageOptions !== false && [
        plugins.remarkImage,
        {
          ...remarkImageOptions,
          useImport: _withoutBundler ? false : remarkImageOptions?.useImport
        }
      ],
      "remarkCodeTab" in plugins && remarkCodeTabOptions !== false && [
        plugins.remarkCodeTab,
        remarkCodeTabOptions
      ],
      "remarkNpm" in plugins && remarkNpmOptions !== false && [plugins.remarkNpm, remarkNpmOptions],
      ...v,
      remarkStructureOptions !== false && [
        plugins.remarkStructure,
        remarkStructureOptions
      ],
      () => {
        return (_, file) => {
          file.data["mdx-export"] ??= [];
          for (const name of valueToExport) {
            if (name in file.data)
              file.data["mdx-export"].push({ name, value: file.data[name] });
          }
        };
      }
    ],
    mdxOptions.remarkPlugins
  );
  const rehypePlugins = pluginOption(
    (v) => [
      rehypeCodeOptions !== false && [plugins.rehypeCode, rehypeCodeOptions],
      ...v,
      plugins.rehypeToc
    ],
    mdxOptions.rehypePlugins
  );
  return {
    ...mdxOptions,
    outputFormat: _withoutBundler ? "function-body" : mdxOptions.outputFormat,
    remarkPlugins,
    rehypePlugins
  };
}
var plugins;
var init_preset = __esm({
  "src/loaders/mdx/preset.ts"() {
    "use strict";
    plugins = __toESM(require("fumadocs-core/mdx-plugins"), 1);
  }
});

// src/config/build.ts
function buildConfig(config) {
  const collections = /* @__PURE__ */ new Map();
  let globalConfig = {};
  for (const [k, v] of Object.entries(config)) {
    if (!v) {
      continue;
    }
    if (typeof v === "object" && "type" in v) {
      if (v.type === "docs") {
        collections.set(k, v);
        continue;
      }
      if (v.type === "doc" || v.type === "meta") {
        collections.set(k, v);
        continue;
      }
    }
    if (k === "default" && v) {
      globalConfig = v;
      continue;
    }
    throw new Error(
      `Unknown export "${k}", you can only export collections from source configuration file.`
    );
  }
  const mdxOptionsCache = /* @__PURE__ */ new Map();
  return {
    global: globalConfig,
    collections,
    async getDefaultMDXOptions(mode = "default") {
      const cached = mdxOptionsCache.get(mode);
      if (cached) return cached;
      const input = this.global.mdxOptions;
      async function uncached() {
        const options = typeof input === "function" ? await input() : input;
        const { getDefaultMDXOptions: getDefaultMDXOptions2 } = await Promise.resolve().then(() => (init_preset(), preset_exports));
        if (options?.preset === "minimal") return options;
        return getDefaultMDXOptions2({
          ...options,
          _withoutBundler: mode === "remote"
        });
      }
      const result = uncached();
      mdxOptionsCache.set(mode, result);
      return result;
    }
  };
}
var init_build = __esm({
  "src/config/build.ts"() {
    "use strict";
  }
});

// src/loaders/config/load.ts
async function compileConfig(configPath, outDir) {
  const { build } = await import("esbuild");
  const transformed = await build({
    entryPoints: [{ in: configPath, out: "source.config" }],
    bundle: true,
    outdir: outDir,
    target: "node20",
    write: true,
    platform: "node",
    format: "esm",
    packages: "external",
    outExtension: {
      ".js": ".mjs"
    },
    allowOverwrite: true
  });
  if (transformed.errors.length > 0) {
    throw new Error("failed to compile configuration file");
  }
}
async function loadConfig(configPath, outDir, hash, build = false) {
  if (cache3 && cache3.hash === hash) {
    return await cache3.config;
  }
  if (build) await compileConfig(configPath, outDir);
  const url = (0, import_node_url2.pathToFileURL)(path7.resolve(outDir, "source.config.mjs"));
  const config = import(`${url.href}?hash=${hash}`).then((loaded) => {
    return buildConfig(
      // every call to `loadConfig` will cause the previous cache to be ignored
      loaded
    );
  });
  if (hash) cache3 = { config, hash };
  return await config;
}
var fs4, path7, import_node_url2, cache3;
var init_load = __esm({
  "src/loaders/config/load.ts"() {
    "use strict";
    fs4 = __toESM(require("fs/promises"), 1);
    path7 = __toESM(require("path"), 1);
    import_node_url2 = require("url");
    init_build();
    cache3 = null;
  }
});

// src/vite/index.ts
var vite_exports = {};
__export(vite_exports, {
  default: () => mdx,
  postInstall: () => postInstall
});
module.exports = __toCommonJS(vite_exports);
var import_vite = require("vite");
init_build();
var import_node_querystring2 = require("querystring");

// src/utils/validation.ts
var import_picocolors = __toESM(require("picocolors"), 1);
var ValidationError = class extends Error {
  constructor(message, issues) {
    super(
      `${message}:
${issues.map((issue) => `  ${issue.path}: ${issue.message}`).join("\n")}`
    );
    this.title = message;
    this.issues = issues;
  }
  toStringFormatted() {
    return [
      import_picocolors.default.bold(`[MDX] ${this.title}:`),
      ...this.issues.map(
        (issue) => import_picocolors.default.redBright(
          `- ${import_picocolors.default.bold(issue.path?.join(".") ?? "*")}: ${issue.message}`
        )
      )
    ].join("\n");
  }
};
async function validate(schema, data, context, errorMessage) {
  if (typeof schema === "function" && !("~standard" in schema)) {
    schema = schema(context);
  }
  if ("~standard" in schema) {
    const result = await schema["~standard"].validate(
      data
    );
    if (result.issues) {
      throw new ValidationError(errorMessage, result.issues);
    }
    return result.value;
  }
  return data;
}

// src/vite/index.ts
var fs6 = __toESM(require("fs/promises"), 1);
var path9 = __toESM(require("path"), 1);
var import_js_yaml2 = require("js-yaml");

// src/utils/import-formatter.ts
var import_node_path = __toESM(require("path"), 1);
function toImportPath(file, config) {
  const ext = import_node_path.default.extname(file);
  let filename;
  if (ext === ".ts" && config.jsExtension) {
    filename = file.substring(0, file.length - ext.length) + ".js";
  } else if (ext === ".ts") {
    filename = file.substring(0, file.length - ext.length);
  } else {
    filename = file;
  }
  let importPath;
  if ("relativeTo" in config) {
    importPath = import_node_path.default.relative(config.relativeTo, filename);
    if (!import_node_path.default.isAbsolute(importPath) && !importPath.startsWith(".")) {
      importPath = `./${importPath}`;
    }
  } else {
    importPath = import_node_path.default.resolve(filename);
  }
  return importPath.replaceAll(import_node_path.default.sep, "/");
}
function ident(code, tab = 1) {
  return code.split("\n").map((v) => "  ".repeat(tab) + v).join("\n");
}

// src/vite/generate-glob.ts
function generateGlob(name, patterns, globOptions) {
  const options = {
    ...globOptions,
    query: {
      ...globOptions?.query,
      collection: name
    }
  };
  return `import.meta.glob(${JSON.stringify(mapGlobPatterns(patterns))}, ${JSON.stringify(options, null, 2)})`;
}
function mapGlobPatterns(patterns) {
  return patterns.map(enforceRelative);
}
function enforceRelative(file) {
  if (file.startsWith("./")) return file;
  if (file.startsWith("/")) return `.${file}`;
  return `./${file}`;
}
function getGlobBase(collection) {
  let dir = collection.dir;
  if (Array.isArray(dir)) {
    if (dir.length !== 1)
      throw new Error(
        `[Fumadocs MDX] Vite Plugin doesn't support multiple \`dir\` for a collection at the moment.`
      );
    dir = dir[0];
  }
  return enforceRelative(dir);
}

// src/utils/collections.ts
function getSupportedFormats(collection) {
  return {
    doc: ["mdx", "md"],
    meta: ["json", "yaml"]
  }[collection.type];
}
function getGlobPatterns(collection) {
  if (collection.files) return collection.files;
  return [`**/*.{${getSupportedFormats(collection).join(",")}}`];
}

// src/vite/generate.ts
function docs(name, collection) {
  const obj = [
    ident(`doc: ${doc(name, collection.docs)}`),
    ident(`meta: ${meta(name, collection.meta)}`)
  ].join(",\n");
  return `{
${obj}
}`;
}
function doc(name, collection) {
  const patterns = getGlobPatterns(collection);
  const base = getGlobBase(collection);
  const docGlob = generateGlob(name, patterns, {
    base
  });
  if (collection.async) {
    const headBlob = generateGlob(name, patterns, {
      query: {
        only: "frontmatter"
      },
      import: "frontmatter",
      base
    });
    return `create.docLazy("${name}", "${base}", ${headBlob}, ${docGlob})`;
  }
  return `create.doc("${name}", "${base}", ${docGlob})`;
}
function meta(name, collection) {
  const patterns = getGlobPatterns(collection);
  const base = getGlobBase(collection);
  return `create.meta("${name}", "${base}", ${generateGlob(name, patterns, {
    import: "default",
    base
  })})`;
}
function entry(configPath, config, outDir, jsExtension) {
  const lines = [
    '/// <reference types="vite/client" />',
    `import { fromConfig } from 'fumadocs-mdx/runtime/vite';`,
    `import type * as Config from '${toImportPath(configPath, {
      relativeTo: outDir,
      jsExtension
    })}';`,
    "",
    `export const create = fromConfig<typeof Config>();`
  ];
  for (const [name, collection] of config.collections.entries()) {
    let body;
    if (collection.type === "docs") {
      body = docs(name, collection);
    } else if (collection.type === "meta") {
      body = meta(name, collection);
    } else {
      body = doc(name, collection);
    }
    lines.push("");
    lines.push(`export const ${name} = ${body};`);
  }
  return lines.join("\n");
}

// src/utils/fuma-matter.ts
var import_js_yaml = require("js-yaml");
var regex = /^---\r?\n(.+?)\r?\n---\r?\n/s;
function fumaMatter(input) {
  const output = { matter: "", data: {}, content: input };
  const match = regex.exec(input);
  if (!match) {
    return output;
  }
  output.matter = match[0];
  output.content = input.slice(match[0].length);
  const loaded = (0, import_js_yaml.load)(match[1]);
  output.data = loaded ?? {};
  return output;
}

// src/utils/git-timestamp.ts
var import_node_path2 = __toESM(require("path"), 1);
var import_tinyexec = require("tinyexec");
var cache = /* @__PURE__ */ new Map();
async function getGitTimestamp(file) {
  const cached = cache.get(file);
  if (cached) return cached;
  try {
    const out = await (0, import_tinyexec.x)(
      "git",
      ["log", "-1", '--pretty="%ai"', import_node_path2.default.relative(process.cwd(), file)],
      {
        throwOnError: true
      }
    );
    const time = new Date(out.stdout);
    cache.set(file, time);
    return time;
  } catch {
    return;
  }
}

// src/loaders/mdx/build-mdx.ts
var import_mdx = require("@mdx-js/mdx");

// src/loaders/mdx/remark-include.ts
var import_unified = require("unified");
var import_unist_util_visit = require("unist-util-visit");
var path3 = __toESM(require("path"), 1);
var fs = __toESM(require("fs/promises"), 1);
var import_remark_parse = __toESM(require("remark-parse"), 1);
var import_remark_mdx = __toESM(require("remark-mdx"), 1);
var import_mdx_plugins = require("fumadocs-core/mdx-plugins");
var ElementLikeTypes = [
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "containerDirective",
  "textDirective",
  "leafDirective"
];
function isElementLike(node) {
  return ElementLikeTypes.includes(node.type);
}
function parseElementAttributes(element) {
  if (Array.isArray(element.attributes)) {
    const attributes = {};
    for (const attr of element.attributes) {
      if (attr.type === "mdxJsxAttribute" && (typeof attr.value === "string" || attr.value === null)) {
        attributes[attr.name] = attr.value;
      }
    }
    return attributes;
  }
  return element.attributes ?? {};
}
function flattenNode(node) {
  if ("children" in node)
    return node.children.map((child) => flattenNode(child)).join("");
  if ("value" in node) return node.value;
  return "";
}
function parseSpecifier(specifier) {
  const idx = specifier.lastIndexOf("#");
  if (idx === -1) return { file: specifier };
  return {
    file: specifier.slice(0, idx),
    section: specifier.slice(idx + 1)
  };
}
function extractSection(root, section) {
  let nodes;
  let capturingHeadingContent = false;
  (0, import_unist_util_visit.visit)(root, (node) => {
    if (node.type === "heading") {
      if (capturingHeadingContent) {
        return false;
      }
      if (node.data?.hProperties?.id === section) {
        capturingHeadingContent = true;
        nodes = [node];
        return "skip";
      }
      return;
    }
    if (capturingHeadingContent) {
      nodes?.push(node);
      return "skip";
    }
    if (isElementLike(node) && node.name === "section") {
      const attributes = parseElementAttributes(node);
      if (attributes.id === section) {
        nodes = node.children;
        return false;
      }
    }
  });
  if (nodes)
    return {
      type: "root",
      children: nodes
    };
}
function remarkInclude() {
  const TagName = "include";
  async function embedContent(file, heading, params, data) {
    let content;
    try {
      content = (await fs.readFile(file)).toString();
    } catch (e) {
      throw new Error(
        `failed to read file ${file}
${e instanceof Error ? e.message : String(e)}`,
        { cause: e }
      );
    }
    const ext = path3.extname(file);
    data._compiler?.addDependency(file);
    if (params.lang || ext !== ".md" && ext !== ".mdx") {
      const lang = params.lang ?? ext.slice(1);
      return {
        type: "code",
        lang,
        meta: params.meta,
        value: content,
        data: {}
      };
    }
    const parser = (data._getProcessor ?? getDefaultProcessor)(
      ext === ".mdx" ? "mdx" : "md"
    );
    const parsed = fumaMatter(content);
    let mdast = parser.parse({
      path: file,
      value: parsed.content,
      data: { frontmatter: parsed.data }
    });
    if (heading) {
      const extracted = extractSection(
        await (0, import_unified.unified)().use(import_mdx_plugins.remarkHeading).run(mdast),
        heading
      );
      if (!extracted)
        throw new Error(
          `Cannot find section ${heading} in ${file}, make sure you have encapsulated the section in a <section id="${heading}"> tag, or a :::section directive with remark-directive configured.`
        );
      mdast = extracted;
    }
    await update(mdast, path3.dirname(file), data);
    return mdast;
  }
  async function update(tree, directory, data) {
    const queue = [];
    (0, import_unist_util_visit.visit)(tree, ElementLikeTypes, (_node, _, parent) => {
      const node = _node;
      if (node.name !== TagName) return;
      const specifier = flattenNode(node);
      if (specifier.length === 0) return "skip";
      const attributes = parseElementAttributes(node);
      const { file: relativePath, section } = parseSpecifier(specifier);
      const file = path3.resolve(
        "cwd" in attributes ? process.cwd() : directory,
        relativePath
      );
      queue.push(
        embedContent(file, section, attributes, data).then((replace) => {
          Object.assign(
            parent && parent.type === "paragraph" ? parent : node,
            replace
          );
        })
      );
      return "skip";
    });
    await Promise.all(queue);
  }
  return async (tree, file) => {
    await update(tree, path3.dirname(file.path), file.data);
  };
}
function getDefaultProcessor(format) {
  const mdProcessor = (0, import_unified.unified)().use(import_remark_parse.default);
  if (format === "md") return mdProcessor;
  return mdProcessor.use(import_remark_mdx.default);
}

// src/loaders/mdx/remark-postprocess.ts
var import_unist_util_visit2 = require("unist-util-visit");
var import_mdast_util_to_markdown = require("mdast-util-to-markdown");
var import_estree_util_value_to_estree = require("estree-util-value-to-estree");
function remarkPostprocess({
  includeProcessedMarkdown = false,
  valueToExport = []
} = {}) {
  return (tree, file) => {
    let title;
    const urls = [];
    (0, import_unist_util_visit2.visit)(tree, ["heading", "link"], (node) => {
      if (node.type === "heading" && node.depth === 1) {
        title = flattenNode2(node);
      }
      if (node.type !== "link") return;
      urls.push({
        href: node.url
      });
      return "skip";
    });
    if (title) {
      file.data.frontmatter ??= {};
      if (!file.data.frontmatter.title) file.data.frontmatter.title = title;
    }
    file.data.extractedReferences = urls;
    if (includeProcessedMarkdown) {
      file.data._markdown = (0, import_mdast_util_to_markdown.toMarkdown)(tree, {
        ...this.data("settings"),
        // from https://github.com/remarkjs/remark/blob/main/packages/remark-stringify/lib/index.js
        extensions: this.data("toMarkdownExtensions") || []
      });
    }
    for (const { name, value } of file.data["mdx-export"] ?? []) {
      tree.children.unshift(getMdastExport(name, value));
    }
    for (const name of valueToExport) {
      if (!(name in file.data)) continue;
      tree.children.unshift(getMdastExport(name, file.data[name]));
    }
  };
}
function getMdastExport(name, value) {
  return {
    type: "mdxjsEsm",
    value: "",
    data: {
      estree: {
        type: "Program",
        sourceType: "module",
        body: [
          {
            type: "ExportNamedDeclaration",
            attributes: [],
            specifiers: [],
            source: null,
            declaration: {
              type: "VariableDeclaration",
              kind: "let",
              declarations: [
                {
                  type: "VariableDeclarator",
                  id: {
                    type: "Identifier",
                    name
                  },
                  init: (0, import_estree_util_value_to_estree.valueToEstree)(value)
                }
              ]
            }
          }
        ]
      }
    }
  };
}
function flattenNode2(node) {
  if ("children" in node)
    return node.children.map((child) => flattenNode2(child)).join("");
  if ("value" in node) return node.value;
  return "";
}

// src/loaders/mdx/build-mdx.ts
var cache2 = /* @__PURE__ */ new Map();
async function buildMDX(cacheKey, source, options) {
  const { filePath, frontmatter, data, _compiler, ...rest } = options;
  function getProcessor(format) {
    const key = `${cacheKey}:${format}`;
    let processor = cache2.get(key);
    if (!processor) {
      processor = (0, import_mdx.createProcessor)({
        outputFormat: "program",
        ...rest,
        remarkPlugins: [
          remarkInclude,
          ...rest.remarkPlugins ?? [],
          [
            remarkPostprocess,
            {
              ...options.postprocess,
              valueToExport: [
                ...options.postprocess?.valueToExport ?? [],
                "structuredData",
                "extractedReferences",
                "frontmatter",
                "lastModified",
                "_markdown"
              ]
            }
          ]
        ],
        format
      });
      cache2.set(key, processor);
    }
    return processor;
  }
  return getProcessor(
    options.format ?? (filePath.endsWith(".mdx") ? "mdx" : "md")
  ).process({
    value: source,
    path: filePath,
    data: {
      ...data,
      frontmatter,
      _compiler,
      _getProcessor: getProcessor
    }
  });
}

// src/loaders/mdx/index.ts
var import_zod = require("zod");
var import_promises = __toESM(require("fs/promises"), 1);
var import_node_path3 = __toESM(require("path"), 1);
var import_node_crypto = require("crypto");
var querySchema = import_zod.z.object({
  only: import_zod.z.literal(["frontmatter", "all"]).default("all"),
  collection: import_zod.z.string().optional(),
  hash: import_zod.z.string().describe(
    "the hash of config, used for revalidation on Turbopack/Webpack."
  ).optional()
}).loose();
var cacheEntry = import_zod.z.object({
  code: import_zod.z.string(),
  map: import_zod.z.any().optional(),
  hash: import_zod.z.string().optional()
});
function createMdxLoader(configLoader) {
  return async ({
    source: value,
    development: isDevelopment,
    query,
    compiler,
    filePath
  }) => {
    const matter = fumaMatter(value);
    const parsed = querySchema.parse(query);
    const loaded = await configLoader.getConfig(parsed.hash);
    const cacheDir = isDevelopment ? void 0 : loaded.global.experimentalBuildCache;
    const cacheKey = `${parsed.hash}_${parsed.collection ?? "global"}_${generateCacheHash(filePath)}`;
    if (cacheDir) {
      const cached = await import_promises.default.readFile(import_node_path3.default.join(cacheDir, cacheKey)).then((content) => cacheEntry.parse(JSON.parse(content.toString()))).catch(() => null);
      if (cached && cached.hash === generateCacheHash(value)) return cached;
    }
    const collection = parsed.collection ? loaded.collections.get(parsed.collection) : void 0;
    let docCollection;
    switch (collection?.type) {
      case "doc":
        docCollection = collection;
        break;
      case "docs":
        docCollection = collection.docs;
        break;
    }
    if (docCollection?.schema) {
      matter.data = await validate(
        docCollection.schema,
        matter.data,
        {
          source: value,
          path: filePath
        },
        `invalid frontmatter in ${filePath}`
      );
    }
    if (parsed.only === "frontmatter") {
      return {
        code: `export const frontmatter = ${JSON.stringify(matter.data)}`,
        map: null
      };
    }
    const data = {};
    if (loaded.global.lastModifiedTime === "git") {
      data.lastModified = (await getGitTimestamp(filePath))?.getTime();
    }
    const lineOffset = isDevelopment ? countLines(matter.matter) : 0;
    const compiled = await buildMDX(
      `${parsed.hash ?? ""}:${parsed.collection ?? "global"}`,
      "\n".repeat(lineOffset) + matter.content,
      {
        development: isDevelopment,
        ...docCollection?.mdxOptions ?? await loaded.getDefaultMDXOptions(),
        postprocess: docCollection?.postprocess,
        data,
        filePath,
        frontmatter: matter.data,
        _compiler: compiler
      }
    );
    const out = {
      code: String(compiled.value),
      map: compiled.map
    };
    if (cacheDir) {
      await import_promises.default.mkdir(cacheDir, { recursive: true });
      await import_promises.default.writeFile(
        import_node_path3.default.join(cacheDir, cacheKey),
        JSON.stringify({
          ...out,
          hash: generateCacheHash(value)
        })
      );
    }
    return out;
  };
}
function generateCacheHash(input) {
  return (0, import_node_crypto.createHash)("md5").update(input).digest("hex");
}
function countLines(s) {
  let num = 0;
  for (const c of s) {
    if (c === "\n") num++;
  }
  return num;
}

// src/loaders/config/index.ts
var import_node_path4 = __toESM(require("path"), 1);
function findConfigFile() {
  return import_node_path4.default.resolve("source.config.ts");
}
function resolvedConfig(loaded) {
  return {
    getConfig() {
      return loaded;
    }
  };
}

// src/loaders/adapter.ts
var import_node_url = require("url");
var import_promises2 = __toESM(require("fs/promises"), 1);
var import_node_querystring = require("querystring");
var import_node_path5 = __toESM(require("path"), 1);
function toVite(loader) {
  return async function(file, query, value) {
    const result = await loader({
      filePath: file,
      query: (0, import_node_querystring.parse)(query),
      source: value,
      development: this.environment.mode === "dev",
      compiler: {
        addDependency: (file2) => {
          this.addWatchFile(file2);
        }
      }
    });
    return {
      code: result.code,
      map: result.map
    };
  };
}

// src/vite/postinstall.ts
init_load();
var import_promises3 = __toESM(require("fs/promises"), 1);
var import_node_path6 = __toESM(require("path"), 1);
async function postInstall(configPath = findConfigFile(), outDir, addJsExtension = false) {
  const config = await loadConfig(configPath, "node_modules", void 0, true);
  const outFile = "source.generated.ts";
  if (outDir) {
    await import_promises3.default.mkdir(outDir, { recursive: true });
  }
  await import_promises3.default.writeFile(
    outDir ? import_node_path6.default.join(outDir, outFile) : outFile,
    entry(configPath, config, outDir ?? process.cwd(), addJsExtension)
  );
  console.log("[MDX] types generated");
}

// src/vite/index.ts
var FumadocsDeps = ["fumadocs-core", "fumadocs-ui", "fumadocs-openapi"];
function mdx(config, options = {}) {
  const {
    generateIndexFile = true,
    updateViteConfig = true,
    configPath = "source.config.ts"
  } = options;
  const loaded = buildConfig(config);
  const mdxLoader = toVite(createMdxLoader(resolvedConfig(loaded)));
  async function transformMeta(path10, query, value) {
    const isJson = path10.endsWith(".json");
    const parsed = (0, import_node_querystring2.parse)(query);
    const collection = parsed.collection ? loaded.collections.get(parsed.collection) : void 0;
    if (!collection) return null;
    let schema;
    switch (collection.type) {
      case "meta":
        schema = collection.schema;
        break;
      case "docs":
        schema = collection.meta.schema;
        break;
    }
    if (!schema) return null;
    let data;
    try {
      data = isJson ? JSON.parse(value) : (0, import_js_yaml2.load)(value);
    } catch {
      return null;
    }
    const out = await validate(
      schema,
      data,
      { path: path10, source: value },
      `invalid data in ${path10}`
    );
    return {
      code: isJson ? JSON.stringify(out) : `export default ${JSON.stringify(out)}`,
      map: null
    };
  }
  return {
    name: "fumadocs-mdx",
    // needed, otherwise other plugins will be executed before our `transform`.
    enforce: "pre",
    config(config2) {
      if (!updateViteConfig) return config2;
      return (0, import_vite.mergeConfig)(config2, {
        optimizeDeps: {
          exclude: FumadocsDeps
        },
        resolve: {
          noExternal: FumadocsDeps,
          dedupe: FumadocsDeps
        }
      });
    },
    async buildStart() {
      if (!generateIndexFile) return;
      const { out = "source.generated.ts", addJsExtension } = typeof generateIndexFile === "object" ? generateIndexFile : {};
      console.log("[Fumadocs MDX] Generating index files");
      const dir = path9.dirname(out);
      await fs6.mkdir(dir, { recursive: true });
      await fs6.writeFile(out, entry(configPath, loaded, dir, addJsExtension));
    },
    async transform(value, id) {
      const [file, query = ""] = id.split("?");
      const ext = path9.extname(file);
      try {
        if ([".yaml", ".json"].includes(ext))
          return await transformMeta(file, query, value);
        if ([".md", ".mdx"].includes(ext))
          return await mdxLoader.call(this, file, query, value);
      } catch (e) {
        if (e instanceof ValidationError) {
          throw new Error(e.toStringFormatted());
        }
        throw e;
      }
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  postInstall
});
