import { createProcessor } from '@mdx-js/mdx';
import { StructuredData } from 'fumadocs-core/mdx-plugins';
import { TableOfContents } from 'fumadocs-core/server';
import { FC, ReactNode } from 'react';
import { MDXProps } from 'mdx/types';
import { E as ExtractedReference, a as DocCollection, b as DocsCollection, M as MetaCollection } from './define-DJbJduHy.js';
import { StandardSchemaV1 } from '@standard-schema/spec';

type Processor = ReturnType<typeof createProcessor>;
interface CompilerOptions {
    addDependency: (file: string) => void;
}
interface CompiledMDXProperties<Frontmatter = Record<string, unknown>> {
    frontmatter: Frontmatter;
    structuredData: StructuredData;
    toc: TableOfContents;
    default: FC<MDXProps>;
    /**
     * Only available when `lastModifiedTime` is enabled on MDX loader
     */
    lastModified?: Date;
    extractedReferences?: ExtractedReference[];
    _markdown?: string;
}
interface FumadocsDataMap {
    /**
     * [Fumadocs MDX] raw frontmatter, you can modify it
     */
    frontmatter?: Record<string, unknown>;
    /**
     * [Fumadocs MDX] additional ESM exports to write
     */
    'mdx-export'?: {
        name: string;
        value: unknown;
    }[];
    extractedReferences: ExtractedReference[];
    /**
     * [Fumadocs MDX] The compiler object from loader
     */
    _compiler?: CompilerOptions;
    _getProcessor?: (format: 'md' | 'mdx') => Processor;
    /**
     * [Fumadocs MDX] Processed Markdown content before `remark-rehype`.
     */
    _markdown?: string;
}
declare module 'vfile' {
    interface DataMap extends FumadocsDataMap {
    }
}

type CompiledMDXFile<Frontmatter> = CompiledMDXProperties<Frontmatter> & Record<string, unknown>;
type DocMap<Frontmatter> = Record<string, (() => Promise<CompiledMDXFile<Frontmatter>>) & {
    base: string;
}>;
type MetaMap<Data> = Record<string, (() => Promise<Data>) & {
    base: string;
}>;
interface LazyDocMap<Frontmatter> {
    base: string;
    head: Record<string, () => Promise<Frontmatter>>;
    body: Record<string, () => Promise<CompiledMDXFile<Frontmatter>>>;
}

interface BaseCreate<Config> {
    doc: <Name extends keyof Config>(name: Name, base: string, glob: Record<string, () => Promise<unknown>>) => Config[Name] extends DocCollection<infer Schema> | DocsCollection<infer Schema> ? DocMap<StandardSchemaV1.InferOutput<Schema>> : never;
    docLazy: <Name extends keyof Config>(name: Name, base: string, headGlob: Record<string, () => Promise<unknown>>, bodyGlob: Record<string, () => Promise<unknown>>) => Config[Name] extends DocCollection<infer Schema> | DocsCollection<infer Schema> ? LazyDocMap<StandardSchemaV1.InferOutput<Schema>> : never;
    meta: <Name extends keyof Config>(name: Name, base: string, glob: Record<string, () => Promise<unknown>>) => Config[Name] extends MetaCollection<infer Schema> | DocsCollection<StandardSchemaV1, infer Schema> ? MetaMap<StandardSchemaV1.InferOutput<Schema>> : never;
}
declare function fromConfigBase<Config>(): BaseCreate<Config>;

interface ClientLoaderOptions<Frontmatter, Props> {
    /**
     * Loader ID (usually your collection name)
     *
     * The code splitting strategy of frameworks like Tanstack Start may duplicate `createClientLoader()` into different chunks.
     *
     * We use loader ID to share cache between multiple instances of client loader.
     *
     * @defaultValue ''
     */
    id?: string;
    component: (loaded: CompiledMDXFile<Frontmatter>, props: Props) => ReactNode;
}
type ClientRenderer<Props> = Record<string, FC<Props>>;
interface ClientLoader<Frontmatter, Props> {
    preload: (path: string) => Promise<CompiledMDXFile<Frontmatter>>;
    /**
     * Get a component that renders content with `React.lazy`
     */
    getComponent: (path: string) => FC<Props>;
    getRenderer: () => ClientRenderer<Props>;
}
declare function createClientLoader<Frontmatter, Props = object>(files: Record<string, () => Promise<CompiledMDXFile<Frontmatter>>>, options: ClientLoaderOptions<Frontmatter, Props>): ClientLoader<Frontmatter, Props>;
declare function toClientRenderer<Frontmatter, Props = object>(files: Record<string, () => Promise<CompiledMDXFile<Frontmatter>>>, component: (loaded: CompiledMDXFile<Frontmatter>, props: Props) => ReactNode): ClientRenderer<Props>;

export { type BaseCreate as B, type ClientLoader as C, type DocMap as D, type LazyDocMap as L, type MetaMap as M, type ClientLoaderOptions as a, type CompiledMDXFile as b, createClientLoader as c, fromConfigBase as f, toClientRenderer as t };
