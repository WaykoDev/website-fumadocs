import { StandardSchemaV1 } from '@standard-schema/spec';
import { Source, PageData, MetaData } from 'fumadocs-core/source';
import { a as DocCollection, M as MetaCollection, b as DocsCollection, G as GlobalConfig } from './define-DJbJduHy.js';
import { ProcessorOptions } from '@mdx-js/mdx';
import { F as FileInfo, D as DocCollectionEntry, M as MetaCollectionEntry, A as AsyncDocCollectionEntry } from './shared-CfiiRctw.js';

interface LoadedConfig {
    collections: Map<string, DocCollection | MetaCollection | DocsCollection>;
    global: GlobalConfig;
    getDefaultMDXOptions(mode?: 'default' | 'remote'): Promise<ProcessorOptions>;
}

interface RuntimeFile {
    info: FileInfo;
    data: Record<string, unknown>;
}
interface AsyncRuntimeFile {
    info: FileInfo & {
        hash?: string;
        absolutePath?: string;
    };
    data: Record<string, unknown>;
    lastModified?: Date;
}
type DocOut<Schema extends StandardSchemaV1 = StandardSchemaV1> = DocCollectionEntry<StandardSchemaV1.InferOutput<Schema>>;
type MetaOut<Schema extends StandardSchemaV1 = StandardSchemaV1> = MetaCollectionEntry<StandardSchemaV1.InferOutput<Schema>>;
interface Runtime {
    doc: <C>(files: RuntimeFile[]) => C extends DocCollection<infer Schema, false> ? DocOut<Schema>[] : never;
    meta: <C>(files: RuntimeFile[]) => C extends MetaCollection<infer Schema> ? MetaOut<Schema>[] : never;
    docs: <C>(docs: RuntimeFile[], metas: RuntimeFile[]) => C extends DocsCollection<infer DocSchema, infer MetaSchema, false> ? {
        docs: DocOut<DocSchema>[];
        meta: MetaOut<MetaSchema>[];
        toFumadocsSource: () => Source<{
            pageData: DocOut<DocSchema> extends PageData ? DocOut<DocSchema> : never;
            metaData: MetaOut<MetaSchema> extends MetaData ? MetaOut<MetaSchema> : never;
        }>;
    } : never;
}
type AsyncDocOut<Schema extends StandardSchemaV1 = StandardSchemaV1> = AsyncDocCollectionEntry<StandardSchemaV1.InferOutput<Schema>>;
interface RuntimeAsync {
    doc: <C>(files: AsyncRuntimeFile[], collection: string, config: LoadedConfig) => C extends DocCollection<infer Schema, true> ? AsyncDocOut<Schema>[] : never;
    docs: <C>(docs: AsyncRuntimeFile[], metas: RuntimeFile[], collection: string, config: LoadedConfig) => C extends DocsCollection<infer DocSchema, infer MetaSchema, true> ? {
        docs: AsyncDocOut<DocSchema>[];
        meta: MetaOut<MetaSchema>[];
        toFumadocsSource: () => Source<{
            pageData: AsyncDocOut<DocSchema> extends PageData ? AsyncDocOut<DocSchema> : never;
            metaData: MetaOut<MetaSchema> extends MetaData ? MetaOut<MetaSchema> : never;
        }>;
    } : never;
}

export type { AsyncRuntimeFile as A, DocOut as D, LoadedConfig as L, MetaOut as M, RuntimeAsync as R, Runtime as a, RuntimeFile as b, AsyncDocOut as c };
