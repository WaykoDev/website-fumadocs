import {
  _runtime,
  createMDXSource
} from "../../chunk-OMAMTKDE.js";
import {
  missingProcessedMarkdown
} from "../../chunk-ZLCSVXCD.js";
import {
  readFileWithCache
} from "../../chunk-ADR6R7HM.js";
import {
  buildConfig
} from "../../chunk-U4MQ44TS.js";
import {
  buildMDX
} from "../../chunk-QAUWMR5D.js";
import "../../chunk-LMG6UWCL.js";
import {
  fumaMatter
} from "../../chunk-VWJKRQZR.js";

// src/runtime/next/async.ts
import { executeMdx } from "@fumadocs/mdx-remote/client";
import { pathToFileURL } from "url";
function getDocCollection(config, collection) {
  const col = config.collections.get(collection);
  if (col?.type === "doc" && col.mdxOptions) return col;
  if (col?.type === "docs" && col.docs.mdxOptions) return col.docs;
}
async function getOptions(config, collection) {
  return collection?.mdxOptions ?? await config.getDefaultMDXOptions("remote");
}
var _runtimeAsync = {
  doc(files, collectionName, config) {
    const collection = getDocCollection(config, collectionName);
    const initMdxOptions = getOptions(config, collection);
    return files.map(({ info, data, lastModified }) => {
      let cachedResult;
      async function compileAndLoad() {
        if (cachedResult) return cachedResult;
        const mdxOptions = await initMdxOptions;
        const raw = await readFileWithCache(info.fullPath);
        const { content } = fumaMatter(raw);
        const compiled = await buildMDX(collectionName, content, {
          ...mdxOptions,
          development: false,
          frontmatter: data,
          postprocess: collection?.postprocess,
          data: {
            lastModified
          },
          filePath: info.fullPath
        });
        const result = await executeMdx(String(compiled.value), {
          baseUrl: pathToFileURL(info.fullPath)
        });
        return cachedResult = result;
      }
      return {
        ...data,
        info,
        async getText(type) {
          if (type === "raw") {
            return readFileWithCache(info.fullPath);
          }
          const out = await compileAndLoad();
          if (typeof out._markdown !== "string") missingProcessedMarkdown();
          return out._markdown;
        },
        async load() {
          const out = await compileAndLoad();
          return {
            _exports: out,
            body: out.default,
            lastModified,
            toc: out.toc,
            extractedReferences: out.extractedReferences,
            structuredData: out.structuredData
          };
        }
      };
    });
  },
  docs(docs, metas, collection, config) {
    const parsedDocs = this.doc(docs, collection, config);
    const parsedMetas = _runtime.meta(metas);
    return {
      docs: parsedDocs,
      meta: parsedMetas,
      toFumadocsSource() {
        return createMDXSource(parsedDocs, parsedMetas);
      }
    };
  }
};
export {
  _runtimeAsync,
  buildConfig
};
